A fantastic challenge! Let's dive into simulating the **Von Kármán Vortex Street** using the **2D Lattice Boltzmann Method (D2Q9)** in R. We'll:

1. Set up a 2D fluid domain with a circular obstacle.
2. Implement the LBM (Lattice Boltzmann Method) with **vectorized streaming**.
3. Compute **vorticity (curl)** at each time step.
4. Animate the flow using **`gganimate`** (or save frames as a GIF).

Here's the complete R script. Buckle up!

**Problem 2: Von Kármán Vortex Street (LBM D2Q9)**
=====================================================

**Theory Quick Recap**
------------------------

The **Lattice Boltzmann Method (D2Q9)** simulates fluid flow by evolving particle distribution functions \( f_i(\mathbf{x}, t) \) on a discrete grid. The steps are:

1. **Collision**: Relax distributions toward equilibrium.
2. **Streaming**: Shift distributions to neighboring lattice nodes.
3. **Boundary Conditions**: Handle walls/obstacles (bounce-back).

For **D2Q9**:
- 9 velocities: \( \mathbf{c}_0 = (0,0) \), \( \mathbf{c}_{1-4} = (\pm 1, 0), (0, \pm 1) \), \( \mathbf{c}_{5-8} = (\pm 1, \pm 1) \).
- Equilibrium \( f_i^{eq} \) depends on density \( \rho \) and velocity \( \mathbf{u} \).
- **Vorticity** \( \omega = \partial v / \partial x - \partial u / \partial y \) highlights rotating structures.

**R Script**
-------------

```r
# Libraries
library(ggplot2)
library(gganimate)
library(dplyr)

# Lattice Boltzmann D2Q9 Parameters
Nx <- 80  # Lattice width
Ny <- 40  # Lattice height
rho0 <- 1 # Background density
u0 <- 0.1 # Inflow velocity (Left to Right)
tau <- 0.6 # Relaxation time (viscosity = (tau - 0.5)/3)
R <- 3    # Obstacle (cylinder) radius
x_c <- 20 # Obstacle center x
y_c <- 20 # Obstacle center y
steps <- 2000 # Simulation time steps

# D2Q9 Lattice Velocities and Weights
c_i <- matrix(c(
  0,  1,  0, -1,  0,  1, -1, -1,  1, # x-components
  0,  0,  1,  0, -1,  1,  1, -1, -1  # y-components
), nrow = 2, byrow = TRUE)
w_i <- c(4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36)

# Initialize distributions: f_i(x,y,t=0)
f <- array(rep(w_i * rho0, Nx * Ny), dim = c(Nx, Ny, 9))

# Precompute equilibrium helper terms
cu2_factor <- 3/2 * (1 / (rho0 * u0)^2)
cu_factor <- 3 / rho0

# Main LBM Loop
vorticity_frames <- list()
for (step in 1:steps) {
  # 0. Compute macroscopic vars: rho(x,y), u(x,y)
  rho <- apply(f, 1:2, sum)
  ux <- (apply(f * c_i[1, ], 1:2, sum)) / rho
  uy <- (apply(f * c_i[2, ], 1:2, sum)) / rho
  
  # Boundary: Inflow (Left) - Fixed velocity u0
  rho[:, 1] <- 1 / (1 - ux[, 1]) * (apply(f[, 1, c(1, 3, 4, 7, 8)], 1, sum) + 
                                    2 * apply(f[, 1, c(2, 5, 6)], 1, sum))
  ux[, 1] <- u0
  uy[, 1] <- 0
  feq <- equilibrium(rho[, 1], ux[, 1], uy[, 1], w_i, c_i, cu_factor, cu2_factor)
  f[, 1, 2] <- feq[, 2] - f[, 1, 4] + feq[, 4]
  f[, 1, 5] <- feq[, 5] - f[, 1, 7] + feq[, 7]
  f[, 1, 6] <- feq[, 6] - f[, 1, 8] + feq[, 8]
  
  # 1. Collision Step (relax toward equilibrium)
  feq <- equilibrium(rho, ux, uy, w_i, c_i, cu_factor, cu2_factor)
  f <- f - (1 / tau) * (f - feq)
  
  # 2. Bounce-back at obstacle (circular cylinder)
  solid_nodes <- (row(f[, , 1]) - x_c)^2 + (col(f[, , 1]) - y_c)^2 <= R^2
  for (i in 1:9) {
    i_opposite <- c(1, 3, 4, 2, 5, 7, 8, 6, 9)[i]
    f[solid_nodes, i] <- f[solid_nodes, i_opposite]
  }
  
  # 3. Streaming Step (vectorized)
  f_new <- f
  for (i in 2:9) { # Skip rest (c_0 = (0,0))
    x_shift <- c_i[1, i]
    y_shift <- c_i[2, i]
    f_new[, , i] <- shift_matrix(f[, , i], x_shift, y_shift)
  }
  f <- f_new
  
  # 4. Outflow (Right) - Zero-gradient
  f[Nx, , ] <- f[Nx - 1, , ]
  
  # 5. Compute vorticity (curl) for visualization
  vorticity <- (c(ux[-1, ] - ux[-Nx, ]) - c(uy[, -1] - uy[, -Ny])) / 2
  vorticity_frames[[step]] <- data.frame(
    x = rep(1:Nx, Ny),
    y = rep(1:Ny, each = Nx),
    vorticity = as.vector(vorticity)
  )
  
  # Progress bar
  if (step %% 100 == 0) cat(sprintf("Step %d/%d\n", step, steps))
}

# Animate vorticity frames using gganimate
vorticity_df <- bind_rows(vorticity_frames, .id = "step")
ggplot(vorticity_df, aes(x, y, fill = vorticity)) +
  geom_raster() +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  labs(title = "Von Kármán Vortex Street (Vorticity)", x = "X", y = "Y", fill = "Vorticity") +
  theme_void() + theme(legend.position = "none") +
  transition_manual(step) +
  ease_aes('linear') -> vorticity_animation

# Save animation as GIF
anim_save("vkarman_vorticity.gif", vorticity_animation, 
          nframes = steps, fps = 30, width = 800, height = 400)
```

**Helper Functions**
---------------------

Add these before the main loop:

```r
# Compute equilibrium distribution
equilibrium <- function(rho, ux, uy, w_i, c_i, cu_factor, cu2_factor) {
  cu <- (ux %o% c_i[1, ]) + (uy %o% c_i[2, ])
  feq <- array(rep(0, length(rho) * 9), dim = c(dim(rho), 9))
  for (i in 1:9) {
    feq[, , i] <- w_i[i] * rho * (1 + cu_factor * cu[, , i] + 
                                   cu2_factor * cu[, , i]^2 - 
                                   cu2_factor * (ux^2 + uy^2))
  }
  feq
}

# Shift matrix (periodic boundaries)
shift_matrix <- function(mat, dx, dy) {
  Nx <- nrow(mat)
  Ny <- ncol(mat)
  x_new <- (1:Nx + dx) %% Nx
  x_new[x_new == 0] <- Nx
  y_new <- (1:Ny + dy) %% Ny
  y_new[y_new == 0] <- Ny
  mat[x_new, y_new]
}
```

**How It Works**
------------------

1. **Initialization**:
   - Set up a `80×40` lattice.
   - `f(x,y,i)` stores particle distributions for 9 velocities.
   - Obstacle: Solid nodes inside \( (x-20)^2 + (y-20)^2 \leq 3^2 \).

2. **Main Loop (LBM Steps)**:
   - **Macroscopic Vars**: Compute \( \rho(x,y) \), \( u_x(x,y) \), \( u_y(x,y) \).
   - **Inflow (Left)**: Zou-He boundary for \( u_x = 0.1 \), \( u_y = 0 \).
   - **Collision**: Relax \( f_i \) toward \( f_i^{eq}(\rho, \mathbf{u}) \).
   - **Bounce-back**: Reflect distributions at solid nodes (obstacle).
   - **Streaming**: Shift \( f_i \) to neighbors (vectorized via `shift_matrix()`).
   - **Outflow (Right)**: Zero-gradient \( \partial f / \partial x = 0 \).

3. **Vorticity Calculation**:
   - Approximate \( \omega = \partial v / \partial x - \partial u / \partial y \) using finite differences.
   - Store frames in `vorticity_frames`.

4. **Animation**:
   - Combine frames into a `data.frame`.
   - `gganimate::transition_manual()` steps through time.
   - `scale_fill_gradient2()` maps vorticity: **Blue (negative, CCW) ↔ White (zero) ↔ Red (positive, CW)**.

**Expected Output**
--------------------

Running the script generates:
1. A **vkarman_vorticity.gif** file in your working directory.
2. The animation shows:
   - Flow from **Left → Right**.
   - **Vortices shedding** alternately from the cylinder's top/bottom.
   - **Blue (counter-clockwise)** and **Red (clockwise)** swirls in the wake.
   - A mesmerizing **Von Kármán Vortex Street**!

**Physics Notes**
------------------

- **Reynolds Number** \( Re = u_0 L / \nu \approx 80 \times 0.1 / (0.1) = 80 \), ideal for vortex shedding.
- Adjust `u0` or `tau` to explore different flow regimes:
  - \( Re < 40 \): Steady flow.
  - \( 40 < Re < 150 \): Laminar vortex street (what we simulate).
  - \( Re > 300 \): Turbulent wake.

**Performance Tips**
---------------------

- **Vectorization**: `shift_matrix()` avoids slow `for` loops.
- Reduce `steps` or `Nx/Ny` for faster debugging.
- Consider **Rcpp** for critical loops (collision/streaming).

Now, hit `Run` and watch those beautiful vortices dance! If you tweak parameters, you'll see fascinating fluid dynamics emerge. Happy simulating!