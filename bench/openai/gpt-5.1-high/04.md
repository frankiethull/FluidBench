```r
############################################################
## 2D Shallow Water "Pond Ripple" with Lax–Wendroff      ##
##  - Gaussian drop in the center                        ##
##  - Hyperbolic SWEs solved on a 2D grid                ##
##  - Final surface rendered with rayshader in 3D        ##
############################################################

## Install packages if needed:
# install.packages(c("rayshader", "rgl", "magrittr"))

library(rayshader)
library(rgl)
library(magrittr)

## ----------------------------
## Physical & numerical params
## ----------------------------
g   <- 9.81        # gravity
h0  <- 1.0         # background water depth
nx  <- 150         # grid size in x
ny  <- 150         # grid size in y
dx  <- 1.0
dy  <- 1.0

# Wave speed and CFL-based time step
c_wave <- sqrt(g * h0)
cfl    <- 0.2
dt     <- cfl * dx / c_wave

# Time until wave hits boundary roughly: L/2c
t_end   <- (min(nx, ny) / 2 - 5) * dx / c_wave
nsteps  <- ceiling(t_end / dt)

cat("dt =", dt, " nsteps =", nsteps, "\n")

## ----------------------------
## Initial condition: Gaussian bump
## ----------------------------
h  <- matrix(h0, nrow = nx, ncol = ny)  # water height
hu <- matrix(0,   nrow = nx, ncol = ny) # x-momentum = h * u
hv <- matrix(0,   nrow = nx, ncol = ny) # y-momentum = h * v

# Gaussian "drop" in center
cx <- (nx + 1) / 2
cy <- (ny + 1) / 2
amp    <- 0.2    # amplitude of bump
sigma  <- 5.0    # width

ii <- row(h)
jj <- col(h)
r2 <- (ii - cx)^2 + (jj - cy)^2
h <- h0 + amp * exp(-r2 / (2 * sigma^2))

# Enforce boundary: tank walls with flat water & no flow
h[1, ]  <- h0;  h[nx, ] <- h0
h[, 1]  <- h0;  h[, ny] <- h0
hu[1, ] <- 0;   hu[nx, ] <- 0
hu[, 1] <- 0;   hu[, ny] <- 0
hv[1, ] <- 0;   hv[nx, ] <- 0
hv[, 1] <- 0;   hv[, ny] <- 0

## ----------------------------
## Helper: one full time step
##  - Richtmyer (two-step Lax–Wendroff) with dimensional splitting
## ----------------------------
step_shallow_water <- function(h, hu, hv, dt, dx, dy, g, h0) {
  nx <- nrow(h); ny <- ncol(h)

  # --- X-sweep (Lax–Wendroff in x) ---

  # Fluxes F(U) = (hu, hu^2/h + 0.5*g*h^2, hu*hv/h)
  F1 <- hu
  F2 <- hu^2 / h + 0.5 * g * h^2
  F3 <- hu * hv / h

  # Predictor: states at i+1/2
  h_half_x  <- 0.5 * (h[2:nx, ]  + h[1:(nx - 1), ]) -
               (dt / (2 * dx)) * (F1[2:nx, ] - F1[1:(nx - 1), ])
  hu_half_x <- 0.5 * (hu[2:nx, ] + hu[1:(nx - 1), ]) -
               (dt / (2 * dx)) * (F2[2:nx, ] - F2[1:(nx - 1), ])
  hv_half_x <- 0.5 * (hv[2:nx, ] + hv[1:(nx - 1), ]) -
               (dt / (2 * dx)) * (F3[2:nx, ] - F3[1:(nx - 1), ])

  # Flux at half-steps
  F1_half_x <- hu_half_x
  F2_half_x <- hu_half_x^2 / h_half_x + 0.5 * g * h_half_x^2
  F3_half_x <- hu_half_x * hv_half_x / h_half_x

  # Corrector: update interior cells in x
  h_x  <- h
  hu_x <- hu
  hv_x <- hv

  idx <- 2:(nx - 1)
  h_x[idx, ]  <- h[idx, ]  - (dt / dx) * (F1_half_x[idx, ]  - F1_half_x[idx - 1, ])
  hu_x[idx, ] <- hu[idx, ] - (dt / dx) * (F2_half_x[idx, ]  - F2_half_x[idx - 1, ])
  hv_x[idx, ] <- hv[idx, ] - (dt / dx) * (F3_half_x[idx, ]  - F3_half_x[idx - 1, ])

  # --- Y-sweep (Lax–Wendroff in y) ---

  # Fluxes G(U) = (hv, hu*hv/h, hv^2/h + 0.5*g*h^2)
  G1 <- hv_x
  G2 <- hu_x * hv_x / h_x
  G3 <- hv_x^2 / h_x + 0.5 * g * h_x^2

  # Predictor: states at j+1/2
  h_half_y  <- 0.5 * (h_x[, 2:ny]  + h_x[, 1:(ny - 1)]) -
               (dt / (2 * dy)) * (G1[, 2:ny] - G1[, 1:(ny - 1)])
  hu_half_y <- 0.5 * (hu_x[, 2:ny] + hu_x[, 1:(ny - 1)]) -
               (dt / (2 * dy)) * (G2[, 2:ny] - G2[, 1:(ny - 1)])
  hv_half_y <- 0.5 * (hv_x[, 2:ny] + hv_x[, 1:(ny - 1)]) -
               (dt / (2 * dy)) * (G3[, 2:ny] - G3[, 1:(ny - 1)])

  # Flux at half-steps
  G1_half_y <- hv_half_y
  G2_half_y <- hu_half_y * hv_half_y / h_half_y
  G3_half_y <- hv_half_y^2 / h_half_y + 0.5 * g * h_half_y^2

  # Corrector: update interior cells in y
  h_new  <- h_x
  hu_new <- hu_x
  hv_new <- hv_x

  idy <- 2:(ny - 1)
  h_new[, idy]  <- h_x[, idy]  - (dt / dy) * (G1_half_y[, idy]  - G1_half_y[, idy - 1])
  hu_new[, idy] <- hu_x[, idy] - (dt / dy) * (G2_half_y[, idy]  - G2_half_y[, idy - 1])
  hv_new[, idy] <- hv_x[, idy] - (dt / dy) * (G3_half_y[, idy]  - G3_half_y[, idy - 1])

  # Tank wall boundary conditions: fixed height and no normal flow
  h_new[1, ]  <- h0;  h_new[nx, ] <- h0
  h_new[, 1]  <- h0;  h_new[, ny] <- h0

  hu_new[1, ] <- 0;   hu_new[nx, ] <- 0
  hu_new[, 1] <- 0;   hu_new[, ny] <- 0

  hv_new[1, ] <- 0;   hv_new[nx, ] <- 0
  hv_new[, 1] <- 0;   hv_new[, ny] <- 0

  # Avoid tiny negative depths from numerical noise
  h_new[h_new < 0.01] <- 0.01

  list(h = h_new, hu = hu_new, hv = hv_new)
}

## ----------------------------
## Time integration
## ----------------------------
for (n in 1:nsteps) {
  out <- step_shallow_water(h, hu, hv, dt, dx, dy, g, h0)
  h   <- out$h
  hu  <- out$hu
  hv  <- out$hv

  if (n %% 50 == 0) {
    cat("Step", n, "of", nsteps, "\n")
  }
}

## ----------------------------
## Rayshader 3D rendering
## ----------------------------
# Use relative height (remove baseline) and ensure positive
heightmap <- h - min(h)

# Blue water-like palette
water_palette <- colorRampPalette(c("#001933", "#003366", "#006699",
                                    "#33aaff", "#cceeff"))

# Shade heightmap with water texture and lighting
water_surface <- heightmap %>%
  height_shade(texture = water_palette(256)) %>%
  add_shadow(ray_shade(heightmap, sunangle = 45, zscale = 5, lambert = TRUE),
             0.7) %>%
  add_shadow(ambient_shade(heightmap, zscale = 5), 0.3)

# 3D plot
plot_3d(
  heightmap,
  water_surface,
  zscale     = 5,         # vertical exaggeration
  fov        = 0,
  theta      = -45,       # viewing angle (azimuth)
  phi        = 35,        # viewing angle (elevation)
  zoom       = 0.75,
  windowsize = c(900, 900),
  background = "white"
)

# High-quality snapshot of the ripple
render_snapshot(
  filename   = "pond_ripple_shallow_water.png",
  title_text = "2D Shallow Water Ripple",
  title_size = 24
)
```

This script:

- Solves the 2D shallow water equations with a two-step Lax–Wendroff (Richtmyer) scheme using dimensional splitting.
- Starts from a flat surface with a Gaussian bump in the center.
- Evolves until the ripple reaches the tank walls.
- Uses `rayshader` to render the final water surface as a 3D blue, lit, and shadowed ripple ring.